# Client Code Guidelines

## Domain-Driven Design

### Directory structure and file naming

All new code should be put under `src/core`, `src/domain` or `src/main`.

- `src/core` contains all components and utilities that are not directly connected to the App business domain. If a file can be potentially reused in another app with a different domain, it should be put into `core`. Examples:
  - `src/core/ui/button/FullWidthButton.tsx`
  - `src/core/ui/dialog/DialogWithGrid.tsx`
- `src/domain` contains components and utilities that are connected with the App domain. Their path and filename should denote to which part of the app domain they belong:
  - `src/domain/challenge/ChallengeDashboardPage.tsx`
  - `src/domain/collaboration/callout/calloutView/CalloutView.tsx`
- `src/main` contains the code that doesn't directly belong to the business domain but is specific to the app, like `PlatformFooter` or `TopLevelDesktopLayout` component:
  - `src/main/routing/RedirectToLanding.tsx`
  - `src/main/ui/platformFooter/PlatformFooter.tsx`

> :warning: Top-level admin pages such as `/admin/spaces` should go under `src/main/admin`.

### Entity names

As some similar entities of the App domain can reuse common components (but still specific to the union of those entities),
instead of choosing locations such as `common` or `shared`, please pick a common term for those entities. For example,
Space, Templates, Admin etc. Components that are reused for all 3 of those
should be placed under the corresponding folder.

### Filename case

Folder names are always _camelCase_.
Files and folders are named using _camelCase_ or _PascalCase_.
For Class/Component/GraphQL use _PascalCase_ (main export => filename).
For hooks, utils, etc. use _camelCase_.
For models (domain types/interfaces) use _camelCase_ + .model.ts. This could be used for constants, context and more.

A file usually inherits the name of its main exported constant. If the constant is a React component named `ComponentName`,
one can expect the file to be named `ComponentName.tsx`.

GraphQL files should be in _PascalCase_ to be consistent with the case of the constants generated by `codegen`.

If a file doesn't have a "main" constant, try to create a descriptive common name, such as `userContext`, `sortingUtils` or `routeBuilder`.

> :warning: We shouldn't try to bring deep structures just to "initially create a proper order".
> E.g.: instead of `challenge/pages/challengeDashboard`, just use `challenge/challengeDashboard`.
> If we are specific enough in domain-based structuring there shouldn't usually be too many files in any specific folder and hence no need for functional file separation.

## Variable naming

### Common conventions:

As typical to Javascript/Typescript code, variables are named using

- `camelCase` if they hold primitives or instances;
- `PascalCase` if they hold classes or constructors (including React functional components).

Constructor-like functions (ones that return an instance but can't be used with `new`)
should be normal camelCase but they should have a prefix like `create` or `setup`
(or `get` for pools/singletons).
Examples:

```tsx
const createLocation: (lat: number, lng: number) => Location = //...
```

```tsx
const getDatabaseConnection: () => DatabaseConnection = //...
```

Constants (shared values that are supposed to be immutable) should use `SCREAMING_SNAKE_CASE`.

Query/Mutation names in GraphQL files should be in _PascalCase_ to be consistent with constants generated by `codegen`.

### React-related conventions:

Variables in a tuple returned by `useState` should form a pair like that:
`const [<variable>, set<variable>] = useState//...` with no exception even if they don't sound great.

Local `boolean` variables should be prefixed with `is`.
On the contrary, `boolean` props shouldn't have any prefix (this convention is derived from HTML boolean attributes).

Example:

```tsx
const [isDialogOpen, setIsDialogOpen] = useState(false);

return <Dialog open={isDialogOpen} />;
```

## Component naming: inheritance + postfixes

In React, we usually implement "inheritance by composition", i.e. we wrap a base component to either:

- preprocess data
- override/decorate callbacks
- wrap the rendered result in extra markup
- provide specific children for the underlying component to render

In all cases above we modify or extend the behavior of the base component by providing some sort of customization.
The name of the created component should reflect the meaning of that extension, e.g. a `Dialog` that allows to use `useColumns()` inside its children, can be named `DialogWithGrid`. If the extension suggests multiple unrelated additions to the original name, consider splitting it into several independent overrides.

> :warning: All classes, components and utils built for Admin side should be prefixed with `Admin`.

> :warning: Many of smaller components have names that clearly show whether it's a dumb or a smart view (e.g. `Button`).
> On the other hand, views used in conjunction with Pages and Containers often share their purpose and naming with them.
> For such views, it makes sense to have `View` explicitly added to their name.
> Examples:
>
> ```tsx
> const Button = () => {}; // No postfix needed
>
> const DashboardPage = () => (
>   <Layout>
>     <DashboardContainer>
>       <DashboardView /> // View postfix allows to easily tell the component role
>     </DashboardContainer>
>   </Layout>
> );
> ```

## Component Roles

### Single Responsibility in React: dumb views vs smart views

A component should clearly belong to one of the following types:

1. A View (dumb component), a function that receives props and returns a formatted result. It should never request the data by utilizing hooks etc. and should not render Containers. A View is unaware of how the App logic is organized or what context it's rendered in (e.g. test or prod environment). A View's props should be one of the following:

   1. Data in the form of primitives, arrays and plain objects.
   2. Callbacks to be attached as event handlers to the rendered elements.
   3. Child elements (ReactElement, ReactNode) and child component implementations (ComponentType). Example: `{ listItemComponent: ComponentType<ItemProps> }` in a list component.

2. A Controller (smart component), a component that does anything except data formatting/rendering:
   1. Data fetching
   2. Managing persistence in localStorage
   3. Route matching

Views should not utilize React.Context much, except for some view-related utilities such as `useTranslation()` or `useColumns()`.

## React Context: when to use and when not

React Context is a convenient way to implement Singletons and Dependency Inversion in React without having to explicitly pass a dependency as a prop through parent components.
Because a Context can access the parent Context, they are also irreplaceable for implicit creation of inherited structures, such as nested grids.
On the other hand, things passed as contexts are provided implicitly and you can't statically check their presence.
If you don't know or can't tell the context where a view is rendered, you can't rely on the availability of a certain React.Context.
The same Context can be mistakenly initialized multiple times (on multiple levels in the render tree) without giving any warnings, consuming extra memory and potentially requesting data multiple times.

If a Context is used to provide a Singleton, such as Space (`useSpace()`), please make sure:

1. Most of the time and for most of the components there exists such a thing as Space and only one instance of it makes sense to be present. You can unambiguously tell which instance is the current one (Space -> by its nameID in the URL).
2. Only the bare minimum of data is provided, the Context doesn't get extended to fit for the purpose of each and every view.
3. There is one level this context is initialized on (for Space, in the Space sub-router). No other initialization points are created to make the context available for a random underlying view.

If a Context is used to create a nested structure, make sure it actually represents a global concept/notion, e.g. Grid Context implements nested grids that are part of Alkemio UX/UI guidelines.

## React Utilities such as useMemo (useCallback)

React provides several optimization techniques that help reduce the number of computations and re-renders, including hooks named `useMemo()` and `useCallback()`.
It's worth to keep in mind a few hints on when to use them and when not.

### useMemo

Usages:

1. You want to avoid running a heavy function on each render, so you wrap the function into `useMemo` to call it only when the parameters change.
   > Usage criteria: the function is likely to cause performance problems.
2. You do data mapping inside your component and you want to avoid creation of new objects or arrays on each render, so that the child components receive objects with the same identity.

   > Usage criteria:
   > your function produces new objects;
   > those objects are passed to child components as props.
   > also: see useCallback

3. If you create a component (`ComponentType`) to pass as a prop, always wrap into `useMemo()` to preserve the component identity. If the component identity changes, React will always remount (that basically disables incremental rendering for the component).

```jsx
// Wrong
const MyComponent = ({ prop }) => {
  const Component = () => <Input color={prop} />;

  return <MyForm inputComponent={Component} />;
};

// Correct
const MyComponent = ({ prop }) => {
  const Component = useMemo(() => () => <Input color={prop} />, [prop]);

  return <MyForm inputComponent={Component} />;
};
```

### useCallback

useCallback is actually a shortcut based on `useMemo()`. It's created for one particular reason: functions defined in your component body are always new instances, recreated on each render. If you pass them as props, the child components props always change. However if you wrap those functions in `useCallback`, the functions won't be redeclared unless their dependencies change.

> :warning: **When not to use:**
> Don't use `useCallback` for the functions that are used in the same component. Unless you pass those functions as props, there's no use in `useCallback`. It doesn't optimize anything about how the function executes.

## TypeScript specifics and "gotchas!"

### `type` **vs** `interface` ~ when to use which [video about it [here](https://youtu.be/zM9UPcIyyhQ?si=BzBMjlqP-rR0jbVg)]

Tests show that there is no significant difference in performance betweet types and interfaces during compilation. It's not critical to use only one approach. It's important to be consistent. However, **recommendation** is to use **type** over **interface** because interfaces come with huge set features which most of the time we don't really care about or need at all. We should use **interface** only when we need to **extend** other interface/s, if this is the only option when working alongside with a third party library or we explicitly need an interface feature. **Type**s provide predicatability and clarity, which is especially beneficial in application development.

> **Conclusion:** Use **type**s for declaring structures unless you require the specific advantages of **interface**s.

### `enum`s considered harmfull [video about it [here](https://youtu.be/jjMbPt_H3RQ?si=Ww4n75eTPOHSfGzh)]

`enum`s are not native to JavaScript! They were introduced in TS to provide a more object-oriented feel, similar to languages like C#. However, even Anders Hejlsberg, one of TypeScript’s creators, mentioned that enums might not have been included if the language were designed today. This is mainly because they are not native to JavaScript and introduce some quirks at runtime.

- **Runtime Behavior**: Numeric enums behave unpredictably when compiled to JavaScript. For example, an enum like: `enum LogLevel { Debug, Warning, Error }` compiles into a JavaScript object that assigns both values to names and names to values. This bidirectional mapping can lead to confusing behavior, especially if you use methods like Object.values().
- **String Enums**: While string enums avoid the bidirectional mapping issue, they somewhat defeat the purpose of using enums, as values must be explicitly assigned.
- **Type System Peculiarities**: TypeScript typically uses a structural type system, meaning it doesn’t care about the names of things, only their shapes. However, enums break this rule. They introduce nominal typing, where the name of the enum itself becomes significant, not just its values. This can complicate code reuse and refactoring.
- **Const Enums**: Const enums optimize enums by stripping them out of the runtime and inlining their values. While this approach eliminates runtime objects, it can lead to issues if the code is used in a library where the compiler isn’t controlled, making them potentially unsafe.
- **Alternative Approach**: A more common modern practice is to use plain JavaScript objects with the as const assertion to define a set of constant values. This method avoids the pitfalls of enums while keeping the benefits of type safety and ease of refactoring. Here's an example:

```ts
const LogLevel = {
  DEBUG: 'DEBUG',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
} as const;

type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
```

**Conclusion**: Although enums provide a structured way to represent constants, their runtime quirks and incompatibilities with TypeScript’s structural typing system make them less desirable for modern codebases. Using constant objects (as const) is a cleaner, safer, and more predictable alternative.

## Component prop types/interfaces

### Structure/nesting

We should avoid putting nested objects into props with the exception of view models, such as `props.callout` for a `CalloutView`.
To simplify passing data into views, view models can have a similar structure to GraphQL models, but they should not be based on GraphQL definitions directly.
It is important that only the values that are really consumed by a view are specified in its props.

> :warning: Don't base View component props on GraphQL definitions (see [Component Roles](#component-roles)). A _View_ should not have imports from `src/core/apollo`.
> On the other hand, return types of _Containers/Hooks_ can (but not necessarily should) be based on GraphQL types.

### View models

As view models are often unique to the view (different views render different properties), there's often no use
in _shared_ view models. To minimize code repetition you can export view props and then refer to them in a parent view:

```ts
interface CalloutsListViewProps {
  callouts: CalloutCardViewProps['callout'][];
  //...
}
```

In this case `CalloutCardViewProps['callout']` becomes a view model that can be reused while keeping the reference to the view
it's used in.

### Props grouping

If the number of props is too high for them to remain ungrouped, please group by domain, not per functional role.
In this case it's both easier to directly pass hook exports as well as proxy those props to the child views.

```ts
// Wrong:
interface PropsByRole {
  entities: {
    callouts: Callout[];
    leadUsers: User[];
  };
  callbacks: {
    updateCallout: () => void;
    refetchLeads: () => void;
  };
}

// Correct:
interface PropsByDomain {
  callouts: {
    callouts: Callout[];
    updateCallout: () => void;
  };
  community: {
    leadUsers: User[];
    refetchLeads: () => void;
  };
}
```

## Containers vs hooks

Hooks were created to replace `Container` components or `High-Order Components (HOCs)` for several reasons:

- they don't increase the tree size
- they don't impose nesting

However, hooks have one limitation: they can't be called conditionally or appear in loops because React identifies hooks by the call order. For cases such
as looping over list items and wrapping them into data fetching logic, we have to fall back to Containers or HOCs.

> :warning: Containers that combine multiple functionalities, such as those that are used in Page components,
> should be based on individual hooks, in which those functionalities are isolated/encapsulated.
>
> One good criteria to determine whether a Container should be based on (or get split into) multiple hooks is
> the ability to give it a name derived from a single App domain area. If you can't come up with a clear name,
> most likely it should be composed of hooks.

> :warning: Please keep in mind that utility functions don't have to be React hooks unless they are include calls to other hooks.

## All-inclusive providers vs per-function providers

Whenever you want to join together some data-fetching and data-manipulation functions, please make sure they belong to the same domain, e.g. `Callouts`. Don't combine multiple domains in one hook. The only exception is creating a `Container` component for a `Page`. Ideally, a `Container` consists of multiple per-domain hooks and/or some small queries too simple to abstract into their own hook.

## Top-level components: Pages, Containers, Views, Layouts. Typical page structure, remounting.

Typically layout/view nesting is done by rendering the common UI parts inside more generic routes (such as `/identity` vs `/:hub`) and putting smaller/nested UI parts into more specific, nested routes such as `/admin/hubs` or `/:hub/dashboard`. However, with this approach you get the following disadvantages:

1. It's impossible to tell by looking at a specific page view (such as Hub Dashboard), what layout it's rendered in.
2. It's hard to control/customize the outer, layout parts of the UI from the specific page view (example: breadcrumbs). You have to rely on `useEffect` and `React.Context`.

Instead of doing that, we render most of the app UI from page components. A typical route/page pair looks like that:

```jsx
const Page = () => {
  return (
    <Layout>
      <Container>
        <View />
      </Container>
    </Layout>
  );
};

<Route path="/page" element={<Page />} />;
```

One obvious downside of it should be that the whole Layout gets remounted when the Page changes even if the next Page renders the same type of Layout.
However, we work around that limitation by "throwing" layout to the top of the tree, where it's rendered by the Layout Holder. For that technique to work, the following must be observed:

1. There should be a `LayoutHolder` component rendered somewhere high in the tree, ideally above all routes. Please see `createLayoutHolder` in `src/core/ui/layout/LayoutHolder/LayoutHolder.tsx`
2. The Layout rendered from a Page should be wrapped in a HOC `createLayout` (returned by `createLayoutHolder`).
3. All Page components should return some type of Layout produced by `createLayout`.

That ensures that as long as the type of the returned Layout stays the same, only its props get updated.

> :information_source: For use within an index Route, use `createLayoutHolderWithOutlet` helper, which adapts `createLayoutHolder` to `react-router`.

> :warning: One important side effect of the described architecture is that the hooks placed in the Page component body would not inherit this special behavior of Layout.
> They will keep the normal behavior of React hooks and will be reinstantiated on each route/page change.
> For efficient data loading it's key to keep all Apollo-related hooks in a `Container` and not place them directly into the `Page.`

The name of a Container or a View for the given page should either

- inherit the page name if its intended usage is exclusive to the Page it's built for;
- have broader naming if they are or can be used in other pages or for other entities.

Pseudocode example:

```jsx
const SpaceDashboardPage = () => {
  return (
    <JourneyLayout level={SpaceLevel.L0}>
      {' '}
      // broader naming
      <SpaceDashboardContainer>
        {' '}
        // specific to the entity/page
        <JourneyDashboardView level={SpaceLevel.L0} /> // generic entity yet specific to the page
      </SpaceDashboardContainer>
    </JourneyLayout>
  );
};
```

## Component Library and Avoidance of code repetition

Any component that represents a self-sufficient UI building block and/or contains CSS tweaks, should be considered a UI Library Component and put into `src/core/ui`.
Domain-specific components should normally not include low-level markup (such as rendering `<div>` or `<Box>`) or CSS with the exception of one-time customization/an exclusive override for a specific page.

## To be done:

### Document actual React.Context usage

### Monolithic page-tailored queries vs smaller reusable queries
